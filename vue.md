#### vue

1. 父子组件传值
   1. A组件引入B组件  那么A组件就是B组件的父组件 同理B组件就是A组件的子组件
   2. 父组件向子组件传值(传方法--方法传参)
      1. 在父组件中动态绑定属性`:形参='父组件中的属性'`(:tr='title')--title是在父组件中的data中定义的属性，tr是父组件向子组件传值的形参，子组件要通过这个属性取值
      2. 在子组件中使用props接受传过来的值(属性要用在父组件中定义的)
      3. 把整个组件传递过去  `:tr='this'`
   3. 父组件主动获取子组件的数据和方法
      1. `<myheader ref="title"></myheader>`通过this.$refs.title可以获取子组件的实例
   4. 子组件主动获取父组件的数据和方法
      1. this.$parent.数据或者方法
2. 声明周期
   1. 创建期间
      1. beforeCreted---data中的数据和methods中的数据都为被初始化
      2. created--数据和方法已经初始化了,，从此可以使用数据和方法了
      3. beforeMount--模版已经在内存中编译完成了，但是尚未渲染到页面 中--可以查找到元素，但是元素的值（内容）还没有被替换------页面上是模版字符串
      4. mounted   内存中的模版已经挂载到了页面中  用户已经可以看到编译好的页面，实例创建期间的最后一个函数，此时如果没有其他操作的话，实例就不会变化
   2. 运行期间
      1. beforeUpdate---数据发生改变的时候会执行-但是还没有更新页面--------事件执行完毕后，再更新虚拟DOM和重新渲染页面
      2. updated----页面已经重新渲染完成
   3. 销毁期间
      1. beforeDestory----此时所有的data和书=methods还有其它都处于可用状态
      2. destory
   4. 如果要操作DOM节点，最早要在mounted中进行

#### 相对路径

1. 相对路径
   1. /1.html  表示跟路径
   2. ./1.html 一个点表示当前路径或者不写.  直接1.html
   3. ../1.html 两个点表示上一级路径

##### Webpack

1. webpack-dev-server---自动打包工具  保存即打包。需要使用npm安装，工具用法和webpack一样

------

在ES6中使用import导入模块，使用export default和 export暴露数据，用export default暴露的成员可以以任何变量来接收，但是以export var title='';暴露的形式，只能以import ｛title｝的形式接收，且变量名必一样。如果要起别名，则可以使用as起别名



import导入模块的查找规则，先在根目录下找有没有node_moudle的文件夹，在node_moudle文件夹根据包名找到对应的文件，最后再包里找packge.json，在package.json里找main属性（main属性指定了包在加载时的入口文件）

weback默认只能处理js类型的文件，并且只能处理低级语法，一些ES6新语法无法识别(需要借助第三方loader)-------比如babel。配置babel的时候后要排除moudle中的



在webpack中，想要通过vue把一个组件放到页面中展示，只能通过render函数

------

所有的Vue组件都是vue实例，并且接收相同的选项对象(一些根实例特有的选项除外)

对于所有的数据绑定，vue都提供给了完全的js表达式语法(但是只支持单个表达式，所以不能使用if else  但是可以使用三元表达式)

指令的值预期是单个js表达式

有些指令还可以接收一个参数（可以理解为形参或者指令的属性）v-bind:title='parade'，title就是v-bind的一个参数或者属性，后面的‘title’是实参或者属性值，以后会根据这个属性获取属性值(父子组件传值)，从2.6.0开始，支持[]括起来的js表达式作为动态参数(和数据绑定还有指令预期值的js表达式一样)

计算属性是基于响应式依赖而进行缓存的--->如果有依赖响应式的属性，则只有当响应式属性改变时，才会重新计算，计算属性默认只有getter，需要的时候可以添加setter

侦听器更适合在一些需要异步操作或开销较大的操作时使用

组件名有驼峰命名和短横线命名两种，当你使用短横线命名时，引用的时候也必须使用短横线名称；但是如果你是用驼峰定义组件时，使用的时候可以使用驼峰有可以使用短横线----------不同于组件和prop，自定义事件名不存在大小写转换和驼峰与短横线格式之间的转换

当想要将一个对象的所有属性都作为prop传入，可以使用不带参数的v-bind来传递给一个对象

prop是单项数据流，不应该在子组件更改prop。如果需要更改，有两种建议，第一：定义一个本地属性，以prop做初始值。第二：使用prop重新定义一个计算属性

默认插槽，没有name属性的插槽(其实是有一个隐含的名字default)，针对组件里同时有具名插槽和匿名插槽的情况，使用组件的时候没有使用v-slot包裹的内容都会被放在匿名插槽里，当然如果希望更明确一些，仍然可以这样使用，<template v-slot:default>--来指明匿名插槽的内容，，，，具名插槽的缩写：v-slot:header===#header

Vue会在初始化实例时，对属性执行getter/setter方法，而Vue又无法检测对象属性的添加或删除，所以属性必须在data对象上才能转换为响应式的

组件的data必须是一个返回对象的函数，当data是一个对象时，组件的所有实例将共享这个对象